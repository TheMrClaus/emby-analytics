[
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_018JCJh5APUp5oKA8B5ZFNKY",
        "type": "tool_result",
        "content": "     1→package emby\n     2→\n     3→import (\n     4→\t\"bytes\"\n     5→\t\"crypto/md5\"\n     6→\t\"encoding/json\"\n     7→\t\"fmt\"\n     8→\t\"io\"\n     9→\t\"net/http\"\n    10→\t\"net/url\"\n    11→\t\"sort\"\n    12→\t\"strings\"\n    13→\t\"sync\"\n    14→\t\"time\"\n    15→)\n    16→\n    17→//\n    18→// ---------- HTTP / JSON helpers ----------\n    19→//\n    20→\n    21→type httpDoer interface {\n    22→\tDo(req *http.Request) (*http.Response, error)\n    23→}\n    24→\n    25→// Heuristic: Emby often reports kbps for sources/streams.\n    26→// Treat small values as kbps; large values as already bps.\n    27→func normalizeToBps(v int64) int64 {\n    28→\tif v < 1_000_000 { // e.g. 57_000 -> 57 Mbps\n    29→\t\treturn v * 1000\n    30→\t}\n    31→\treturn v\n    32→}\n    33→\n    34→// readJSON enforces 200 OK and JSON-decodes into dst.\n    35→// On failure, it returns an error that includes status and a short body snippet.\n    36→func readJSON(resp *http.Response, dst any) error {\n    37→\tdefer resp.Body.Close()\n    38→\n    39→\tb, err := io.ReadAll(resp.Body)\n    40→\tif err != nil {\n    41→\t\treturn fmt.Errorf(\"read body: %w\", err)\n    42→\t}\n    43→\n    44→\tif resp.StatusCode != http.StatusOK {\n    45→\t\tsnippet := string(b)\n    46→\t\tif len(snippet) > 240 {\n    47→\t\t\tsnippet = snippet[:240] + \"…\"\n    48→\t\t}\n    49→\t\treturn fmt.Errorf(\"http %d from %s: %s\", resp.StatusCode, resp.Request.URL.String(), snippet)\n    50→\t}\n    51→\n    52→\t// Optional: check content-type is JSON-ish (don't be too strict)\n    53→\tct := resp.Header.Get(\"Content-Type\")\n    54→\tif ct != \"\" && !strings.Contains(strings.ToLower(ct), \"application/json\") {\n    55→\t\t// still try to decode, but if it fails we'll show a snippet\n    56→\t}\n    57→\n    58→\tif err := json.Unmarshal(b, dst); err != nil {\n    59→\t\tsnippet := string(b)\n    60→\t\tif len(snippet) > 240 {\n    61→\t\t\tsnippet = snippet[:240] + \"…\"\n    62→\t\t}\n    63→\t\treturn fmt.Errorf(\"decode json from %s: %w; body: %q\", resp.Request.URL.String(), err, snippet)\n    64→\t}\n    65→\treturn nil\n    66→}\n    67→\n    68→// doWithRetry performs HTTP request with exponential backoff retry\n    69→func (c *Client) doWithRetry(req *http.Request, maxRetries int) (*http.Response, error) {\n    70→\tvar lastErr error\n    71→\tfor attempt := 0; attempt <= maxRetries; attempt++ {\n    72→\t\t// Clone the request for retry attempts\n    73→\t\tvar reqClone *http.Request\n    74→\t\tif attempt > 0 {\n    75→\t\t\treqClone = req.Clone(req.Context())\n    76→\t\t} else {\n    77→\t\t\treqClone = req\n    78→\t\t}\n    79→\n    80→\t\tresp, err := c.http.Do(reqClone)\n    81→\t\tif err == nil && resp.StatusCode < 500 {\n    82→\t\t\t// Success or client error (don't retry client errors)\n    83→\t\t\treturn resp, nil\n    84→\t\t}\n    85→\t\t\n    86→\t\tif resp != nil {\n    87→\t\t\tresp.Body.Close()\n    88→\t\t}\n    89→\t\t\n    90→\t\tlastErr = err\n    91→\t\tif err == nil {\n    92→\t\t\tlastErr = fmt.Errorf(\"server error: %d\", resp.StatusCode)\n    93→\t\t}\n    94→\t\t\n    95→\t\tif attempt < maxRetries {\n    96→\t\t\t// Exponential backoff: 1s, 2s, 4s, 8s\n    97→\t\t\tbackoff := time.Duration(1<<uint(attempt)) * time.Second\n    98→\t\t\ttime.Sleep(backoff)\n    99→\t\t}\n   100→\t}\n   101→\t\n   102→\treturn nil, fmt.Errorf(\"request failed after %d attempts: %w\", maxRetries+1, lastErr)\n   103→}\n   104→\n   105→//\n   106→// ---------- Client ----------\n   107→//\n   108→\n   109→type Client struct {\n   110→\tBaseURL  string\n   111→\tAPIKey   string\n   112→\thttp     *http.Client\n   113→\tcache    sync.Map\n   114→\tcacheTTL time.Duration\n   115→}\n   116→\n   117→func New(baseURL, apiKey string) *Client {\n   118→\treturn &Client{\n   119→\t\tBaseURL:  strings.TrimRight(baseURL, \"/\"),\n   120→\t\tAPIKey:   apiKey,\n   121→\t\tcacheTTL: time.Hour, // 1 hour TTL\n   122→\t\thttp: &http.Client{\n   123→\t\t\tTimeout: 30 * time.Second, // Increased from 15s to 30s\n   124→\t\t\tTransport: &http.Transport{\n   125→\t\t\t\tMaxIdleConns:        10,\n   126→\t\t\t\tIdleConnTimeout:     30 * time.Second,\n   127→\t\t\t\tDisableCompression:  false,\n   128→\t\t\t},\n   129→\t\t},\n   130→\t}\n   131→}\n   132→\n   133→type cacheEntry struct {\n   134→\tdata      []EmbyItem\n   135→\ttimestamp time.Time\n   136→}\n   137→\n   138→//\n   139→// ---------- Library (items, codecs, counts) ----------\n   140→//\n   141→\n   142→type EmbyItem struct {\n   143→\tId                string `json:\"Id\"`\n   144→\tName              string `json:\"Name\"`\n   145→\tType              string `json:\"Type\"`\n   146→\tSeriesName        string `json:\"SeriesName\"`\n   147→\tParentIndexNumber *int   `json:\"ParentIndexNumber\"` // season\n   148→\tIndexNumber       *int   `json:\"IndexNumber\"`       // episode\n   149→}\n   150→\n   151→type embyItemsResp struct {\n   152→\tItems []EmbyItem `json:\"Items\"`\n   153→}\n   154→\n   155→// generateCacheKey creates a consistent cache key from item IDs\n   156→func (c *Client) generateCacheKey(ids []string) string {\n   157→\tif len(ids) == 0 {\n   158→\t\treturn \"\"\n   159→\t}\n   160→\n   161→\t// Sort IDs to ensure consistent cache keys regardless of order\n   162→\tsorted := make([]string, len(ids))\n   163→\tcopy(sorted, ids)\n   164→\tsort.Strings(sorted)\n   165→\n   166→\t// Create MD5 hash of sorted IDs\n   167→\th := md5.New()\n   168→\tfor _, id := range sorted {\n   169→\t\th.Write([]byte(id))\n   170→\t\th.Write([]byte(\",\"))\n   171→\t}\n   172→\treturn fmt.Sprintf(\"items_%x\", h.Sum(nil))\n   173→}\n   174→\n   175→// getCachedItems retrieves cached items if they exist and are not expired\n   176→func (c *Client) getCachedItems(cacheKey string) ([]EmbyItem, bool) {\n   177→\tif cacheKey == \"\" {\n   178→\t\treturn nil, false\n   179→\t}\n   180→\n   181→\tif entry, exists := c.cache.Load(cacheKey); exists {\n   182→\t\tif cached, ok := entry.(cacheEntry); ok {\n   183→\t\t\tif time.Since(cached.timestamp) < c.cacheTTL {\n   184→\t\t\t\treturn cached.data, true\n   185→\t\t\t}\n   186→\t\t\t// Entry is expired, remove it\n   187→\t\t\tc.cache.Delete(cacheKey)\n   188→\t\t}\n   189→\t}\n   190→\treturn nil, false\n   191→}\n   192→\n   193→// setCachedItems stores items in cache\n   194→func (c *Client) setCachedItems(cacheKey string, items []EmbyItem) {\n   195→\tif cacheKey == \"\" {\n   196→\t\treturn\n   197→\t}\n   198→\n   199→\tentry := cacheEntry{\n   200→\t\tdata:      items,\n   201→\t\ttimestamp: time.Now(),\n   202→\t}\n   203→\tc.cache.Store(cacheKey, entry)\n   204→}\n   205→\n   206→// ItemsByIDs fetches item details for a set of IDs (used to prettify Episode display)\n   207→// ItemsByIDs fetches item details for a set of IDs (used to prettify Episode display)\n   208→func (c *Client) ItemsByIDs(ids []string) ([]EmbyItem, error) {\n   209→\tif c == nil || c.BaseURL == \"\" || c.APIKey == \"\" || len(ids) == 0 {\n   210→\t\treturn []EmbyItem{}, nil\n   211→\t}\n   212→\n   213→\t// Generate cache key\n   214→\tcacheKey := c.generateCacheKey(ids)\n   215→\n   216→\t// Check cache first\n   217→\tif cachedItems, found := c.getCachedItems(cacheKey); found {\n   218→\t\treturn cachedItems, nil\n   219→\t}\n   220→\n   221→\t// Cache miss - fetch from API\n   222→\tendpoint := fmt.Sprintf(\"%s/emby/Items\", c.BaseURL)\n   223→\tq := url.Values{}\n   224→\tq.Set(\"api_key\", c.APIKey)\n   225→\tq.Set(\"Ids\", strings.Join(ids, \",\"))\n   226→\n   227→\treq, _ := http.NewRequest(\"GET\", endpoint+\"?\"+q.Encode(), nil)\n   228→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   229→\n   230→\tresp, err := c.doWithRetry(req, 2) // Retry up to 2 times\n   231→\tif err != nil {\n   232→\t\treturn nil, err\n   233→\t}\n   234→\n   235→\tvar out embyItemsResp\n   236→\tif err := readJSON(resp, &out); err != nil {\n   237→\t\treturn nil, err\n   238→\t}\n   239→\n   240→\t// Cache the result\n   241→\tc.setCachedItems(cacheKey, out.Items)\n   242→\n   243→\treturn out.Items, nil\n   244→}\n   245→\n   246→type LibraryItem struct {\n   247→\tId     string `json:\"Id\"`\n   248→\tName   string `json:\"Name\"`\n   249→\tType   string `json:\"Type\"`\n   250→\tHeight *int   `json:\"Height,omitempty\"`\n   251→\tWidth  *int   `json:\"Width,omitempty\"`\n   252→\tCodec  string `json:\"VideoCodec,omitempty\"`\n   253→}\n   254→\n   255→// Detailed struct for fetching media info with codec data\n   256→type DetailedLibraryItem struct {\n   257→\tId           string `json:\"Id\"`\n   258→\tName         string `json:\"Name\"`\n   259→\tType         string `json:\"Type\"`\n   260→\tMediaSources []struct {\n   261→\t\tMediaStreams []struct {\n   262→\t\t\tType   string `json:\"Type\"`\n   263→\t\t\tCodec  string `json:\"Codec\"`\n   264→\t\t\tHeight *int   `json:\"Height\"`\n   265→\t\t\tWidth  *int   `json:\"Width\"`\n   266→\t\t} `json:\"MediaStreams\"`\n   267→\t} `json:\"MediaSources\"`\n   268→}\n   269→\n   270→type itemsResp struct {\n   271→\tItems []LibraryItem `json:\"Items\"`\n   272→\tTotal int           `json:\"TotalRecordCount\"`\n   273→}\n   274→\n   275→func (c *Client) TotalItems() (int, error) {\n   276→\tu := fmt.Sprintf(\"%s/emby/Items\", c.BaseURL)\n   277→\tq := url.Values{}\n   278→\tq.Set(\"api_key\", c.APIKey)\n   279→\tq.Set(\"IncludeItemTypes\", \"Movie,Episode\") // Only count video items\n   280→\tq.Set(\"Recursive\", \"true\")\n   281→\tq.Set(\"StartIndex\", \"0\")\n   282→\tq.Set(\"Limit\", \"1\")\n   283→\n   284→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   285→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   286→\n   287→\tresp, err := c.http.Do(req)\n   288→\tif err != nil {\n   289→\t\treturn 0, err\n   290→\t}\n   291→\n   292→\tvar out itemsResp\n   293→\tif err := readJSON(resp, &out); err != nil {\n   294→\t\treturn 0, err\n   295→\t}\n   296→\treturn out.Total, nil\n   297→}\n   298→\n   299→// GetItemsIncremental fetches items modified since a given timestamp for incremental sync\n   300→func (c *Client) GetItemsIncremental(limit int, minDateLastSaved *time.Time) ([]LibraryItem, int, error) {\n   301→\tu := fmt.Sprintf(\"%s/emby/Items\", c.BaseURL)\n   302→\tq := url.Values{}\n   303→\tq.Set(\"api_key\", c.APIKey)\n   304→\tq.Set(\"Fields\", \"MediaSources,MediaStreams\")\n   305→\tq.Set(\"Recursive\", \"true\")\n   306→\tq.Set(\"Limit\", fmt.Sprintf(\"%d\", limit))\n   307→\tq.Set(\"IncludeItemTypes\", \"Movie,Episode\") // Only get video items\n   308→\t\n   309→\t// Add incremental sync parameter\n   310→\tif minDateLastSaved != nil {\n   311→\t\tq.Set(\"MinDateLastSaved\", minDateLastSaved.Format(time.RFC3339))\n   312→\t}\n   313→\n   314→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   315→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   316→\n   317→\tresp, err := c.http.Do(req)\n   318→\tif err != nil {\n   319→\t\treturn nil, 0, err\n   320→\t}\n   321→\n   322→\tvar out struct {\n   323→\t\tItems []DetailedLibraryItem `json:\"Items\"`\n   324→\t\tTotalRecordCount int `json:\"TotalRecordCount\"`\n   325→\t}\n   326→\tif err := readJSON(resp, &out); err != nil {\n   327→\t\treturn nil, 0, err\n   328→\t}\n   329→\n   330→\t// Convert to LibraryItem format, creating ONE entry per media item\n   331→\tvar result []LibraryItem\n   332→\n   333→\tfor _, item := range out.Items {\n   334→\t\tvar firstVideoCodec string\n   335→\t\tvar firstVideoHeight *int\n   336→\t\tvar firstVideoWidth *int\n   337→\n   338→\t\t// Find the FIRST video stream only (matches C# plugin logic)\n   339→\t\tfor _, source := range item.MediaSources {\n   340→\t\t\tfor _, stream := range source.MediaStreams {\n   341→\t\t\t\tif stream.Type == \"Video\" && stream.Codec != \"\" {\n   342→\t\t\t\t\tfirstVideoCodec = stream.Codec\n   343→\t\t\t\t\tfirstVideoHeight = stream.Height\n   344→\t\t\t\t\tfirstVideoWidth = stream.Width\n   345→\t\t\t\t\tgoto found // Break out of both loops\n   346→\t\t\t\t}\n   347→\t\t\t}\n   348→\t\t}\n   349→\n   350→\tfound:\n   351→\t\t// Set codec to \"Unknown\" if no video stream found\n   352→\t\tif firstVideoCodec == \"\" {\n   353→\t\t\tfirstVideoCodec = \"Unknown\"\n   354→\t\t}\n   355→\n   356→\t\t// Create ONE LibraryItem entry per media item\n   357→\t\tresult = append(result, LibraryItem{\n   358→\t\t\tId:     item.Id, // Use original ID without suffix\n   359→\t\t\tName:   item.Name,\n   360→\t\t\tType:   item.Type,\n   361→\t\t\tHeight: firstVideoHeight,\n   362→\t\t\tWidth:  firstVideoWidth,\n   363→\t\t\tCodec:  firstVideoCodec,\n   364→\t\t})\n   365→\t}\n   366→\n   367→\treturn result, out.TotalRecordCount, nil\n   368→}\n   369→\n   370→// GetItemsChunk extracts codec data from MediaStreams - one entry per media item\n   371→func (c *Client) GetItemsChunk(limit, page int) ([]LibraryItem, error) {\n   372→\tu := fmt.Sprintf(\"%s/emby/Items\", c.BaseURL)\n   373→\tq := url.Values{}\n   374→\tq.Set(\"api_key\", c.APIKey)\n   375→\tq.Set(\"Fields\", \"MediaSources,MediaStreams\")\n   376→\tq.Set(\"Recursive\", \"true\")\n   377→\tq.Set(\"StartIndex\", fmt.Sprintf(\"%d\", page*limit))\n   378→\tq.Set(\"Limit\", fmt.Sprintf(\"%d\", limit))\n   379→\tq.Set(\"IncludeItemTypes\", \"Movie,Episode\") // Only get video items\n   380→\n   381→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   382→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   383→\n   384→\tresp, err := c.http.Do(req)\n   385→\tif err != nil {\n   386→\t\treturn nil, err\n   387→\t}\n   388→\n   389→\tvar out struct {\n   390→\t\tItems []DetailedLibraryItem `json:\"Items\"`\n   391→\t}\n   392→\tif err := readJSON(resp, &out); err != nil {\n   393→\t\treturn nil, err\n   394→\t}\n   395→\n   396→\t// Convert to LibraryItem format, creating ONE entry per media item\n   397→\tvar result []LibraryItem\n   398→\n   399→\tfor _, item := range out.Items {\n   400→\t\tvar firstVideoCodec string\n   401→\t\tvar firstVideoHeight *int\n   402→\t\tvar firstVideoWidth *int\n   403→\n   404→\t\t// Find the FIRST video stream only (matches C# plugin logic)\n   405→\t\tfor _, source := range item.MediaSources {\n   406→\t\t\tfor _, stream := range source.MediaStreams {\n   407→\t\t\t\tif stream.Type == \"Video\" && stream.Codec != \"\" {\n   408→\t\t\t\t\tfirstVideoCodec = stream.Codec\n   409→\t\t\t\t\tfirstVideoHeight = stream.Height\n   410→\t\t\t\t\tfirstVideoWidth = stream.Width\n   411→\t\t\t\t\tgoto found // Break out of both loops\n   412→\t\t\t\t}\n   413→\t\t\t}\n   414→\t\t}\n   415→\n   416→\tfound:\n   417→\t\t// Set codec to \"Unknown\" if no video stream found\n   418→\t\tif firstVideoCodec == \"\" {\n   419→\t\t\tfirstVideoCodec = \"Unknown\"\n   420→\t\t}\n   421→\n   422→\t\t// Create ONE LibraryItem entry per media item\n   423→\t\tresult = append(result, LibraryItem{\n   424→\t\t\tId:     item.Id, // Use original ID without suffix\n   425→\t\t\tName:   item.Name,\n   426→\t\t\tType:   item.Type,\n   427→\t\t\tHeight: firstVideoHeight,\n   428→\t\t\tWidth:  firstVideoWidth,\n   429→\t\t\tCodec:  firstVideoCodec,\n   430→\t\t})\n   431→\t}\n   432→\n   433→\treturn result, nil\n   434→}\n   435→\n   436→//\n   437→// ---------- Users & history ----------\n   438→//\n   439→\n   440→type EmbyUser struct {\n   441→\tId   string `json:\"Id\"`\n   442→\tName string `json:\"Name\"`\n   443→}\n   444→\n   445→// Struct for history items\n   446→type PlayHistoryItem struct {\n   447→\tId          string `json:\"Id\"`\n   448→\tName        string `json:\"Name\"`\n   449→\tType        string `json:\"Type\"`\n   450→\tDatePlayed  string `json:\"DatePlayed\"` // ISO8601\n   451→\tPlaybackPos int64  `json:\"PlaybackPositionTicks\"`\n   452→\tUserID      string `json:\"-\"`\n   453→}\n   454→\n   455→type playHistoryResp struct {\n   456→\tItems []PlayHistoryItem `json:\"Items\"`\n   457→}\n   458→\n   459→// GetUserPlayHistory returns recent items played by a user (daysBack is how many days to look back)\n   460→func (c *Client) GetUserPlayHistory(userID string, daysBack int) ([]PlayHistoryItem, error) {\n   461→\tu := fmt.Sprintf(\"%s/emby/Users/%s/Items\", c.BaseURL, userID)\n   462→\tq := url.Values{}\n   463→\tq.Set(\"api_key\", c.APIKey)\n   464→\tq.Set(\"SortBy\", \"DatePlayed\")\n   465→\tq.Set(\"SortOrder\", \"Descending\")\n   466→\tq.Set(\"Filters\", \"IsPlayed\")\n   467→\tq.Set(\"Recursive\", \"true\")\n   468→\tq.Set(\"Limit\", \"100\")\n   469→\tif daysBack > 0 {\n   470→\t\tfrom := time.Now().AddDate(0, 0, -daysBack).Format(time.RFC3339)\n   471→\t\tq.Set(\"MinDatePlayed\", from)\n   472→\t}\n   473→\n   474→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   475→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   476→\n   477→\tresp, err := c.http.Do(req)\n   478→\tif err != nil {\n   479→\t\treturn nil, err\n   480→\t}\n   481→\n   482→\tvar out struct {\n   483→\t\tItems []PlayHistoryItem `json:\"Items\"`\n   484→\t}\n   485→\tif err := readJSON(resp, &out); err != nil {\n   486→\t\treturn nil, err\n   487→\t}\n   488→\n   489→\t// Attach userID so downstream logic knows which user played it\n   490→\tfor i := range out.Items {\n   491→\t\tout.Items[i].UserID = userID\n   492→\t}\n   493→\treturn out.Items, nil\n   494→}\n   495→\n   496→// GetUserRecentActivity returns ALL recent items with playback activity (not just \"played\" ones)\n   497→func (c *Client) GetUserRecentActivity(userID string, daysBack int) ([]PlayHistoryItem, error) {\n   498→\tu := fmt.Sprintf(\"%s/emby/Users/%s/Items\", c.BaseURL, userID)\n   499→\tq := url.Values{}\n   500→\tq.Set(\"api_key\", c.APIKey)\n   501→\tq.Set(\"SortBy\", \"DatePlayed\")\n   502→\tq.Set(\"SortOrder\", \"Descending\")\n   503→\t// NOTE: Removed \"IsPlayed\" filter to show partially watched items too\n   504→\tq.Set(\"Recursive\", \"true\")\n   505→\tq.Set(\"Limit\", \"100\")\n   506→\tq.Set(\"Fields\", \"UserData\")\n   507→\n   508→\tif daysBack > 0 {\n   509→\t\tfrom := time.Now().AddDate(0, 0, -daysBack).Format(time.RFC3339)\n   510→\t\tq.Set(\"MinDatePlayed\", from)\n   511→\t}\n   512→\n   513→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   514→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   515→\n   516→\tresp, err := c.http.Do(req)\n   517→\tif err != nil {\n   518→\t\treturn nil, err\n   519→\t}\n   520→\n   521→\tvar out struct {\n   522→\t\tItems []struct {\n   523→\t\t\tId       string `json:\"Id\"`\n   524→\t\t\tName     string `json:\"Name\"`\n   525→\t\t\tType     string `json:\"Type\"`\n   526→\t\t\tUserData struct {\n   527→\t\t\t\tLastPlayedDate        string `json:\"LastPlayedDate\"`\n   528→\t\t\t\tPlaybackPositionTicks int64  `json:\"PlaybackPositionTicks\"`\n   529→\t\t\t\tPlayed                bool   `json:\"Played\"`\n   530→\t\t\t\tPlayCount             int    `json:\"PlayCount\"`\n   531→\t\t\t} `json:\"UserData\"`\n   532→\t\t} `json:\"Items\"`\n   533→\t}\n   534→\tif err := readJSON(resp, &out); err != nil {\n   535→\t\treturn nil, err\n   536→\t}\n   537→\n   538→\t// Convert to PlayHistoryItem format\n   539→\tresult := make([]PlayHistoryItem, 0, len(out.Items))\n   540→\tfor _, item := range out.Items {\n   541→\t\t// Use LastPlayedDate if available, otherwise skip\n   542→\t\tdateToUse := item.UserData.LastPlayedDate\n   543→\t\tif dateToUse == \"\" {\n   544→\t\t\tcontinue\n   545→\t\t}\n   546→\n   547→\t\tresult = append(result, PlayHistoryItem{\n   548→\t\t\tId:          item.Id,\n   549→\t\t\tName:        item.Name,\n   550→\t\t\tType:        item.Type,\n   551→\t\t\tDatePlayed:  dateToUse,\n   552→\t\t\tPlaybackPos: item.UserData.PlaybackPositionTicks,\n   553→\t\t\tUserID:      userID,\n   554→\t\t})\n   555→\t}\n   556→\n   557→\treturn result, nil\n   558→}\n   559→\n   560→type usersResp struct {\n   561→\tItems []EmbyUser `json:\"Items\"`\n   562→}\n   563→\n   564→// GetUsers fetches minimal user data (Id, Name) from Emby server.\n   565→// Tries direct array first; if not, retries on the wrapped format.\n   566→func (c *Client) GetUsers() ([]EmbyUser, error) {\n   567→\tu := fmt.Sprintf(\"%s/emby/Users\", c.BaseURL)\n   568→\tq := url.Values{}\n   569→\tq.Set(\"api_key\", c.APIKey)\n   570→\tq.Set(\"Fields\", \"\") // minimal fields\n   571→\n   572→\tmakeReq := func() (*http.Response, error) {\n   573→\t\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   574→\t\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   575→\t\treturn c.http.Do(req)\n   576→\t}\n   577→\n   578→\t// Try direct array first\n   579→\tresp, err := makeReq()\n   580→\tif err != nil {\n   581→\t\treturn nil, err\n   582→\t}\n   583→\tvar users []EmbyUser\n   584→\tif err := readJSON(resp, &users); err == nil {\n   585→\t\treturn users, nil\n   586→\t}\n   587→\n   588→\t// Fallback: wrapped payload\n   589→\tresp, err = makeReq()\n   590→\tif err != nil {\n   591→\t\treturn nil, err\n   592→\t}\n   593→\tvar out usersResp\n   594→\tif err := readJSON(resp, &out); err != nil {\n   595→\t\treturn nil, err\n   596→\t}\n   597→\treturn out.Items, nil\n   598→}\n   599→\n   600→// GetUserData fetches user's watch status for items\n   601→func (c *Client) GetUserData(userID string) ([]UserDataItem, error) {\n   602→\tu := fmt.Sprintf(\"%s/emby/Users/%s/Items\", c.BaseURL, userID)\n   603→\tq := url.Values{}\n   604→\tq.Set(\"api_key\", c.APIKey)\n   605→\tq.Set(\"Recursive\", \"true\")\n   606→\tq.Set(\"Fields\", \"UserData,RunTimeTicks\")\n   607→\tq.Set(\"IncludeItemTypes\", \"Movie,Episode\")\n   608→\tq.Set(\"Filters\", \"IsPlayed\")\n   609→\n   610→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   611→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   612→\n   613→\tresp, err := c.http.Do(req)\n   614→\tif err != nil {\n   615→\t\treturn nil, err\n   616→\t}\n   617→\n   618→\tvar out struct {\n   619→\t\tItems []UserDataItem `json:\"Items\"`\n   620→\t}\n   621→\tif err := readJSON(resp, &out); err != nil {\n   622→\t\treturn nil, err\n   623→\t}\n   624→\n   625→\treturn out.Items, nil\n   626→}\n   627→\n   628→type UserDataItem struct {\n   629→\tId           string `json:\"Id\"`\n   630→\tName         string `json:\"Name\"`\n   631→\tType         string `json:\"Type\"`\n   632→\tRunTimeTicks int64  `json:\"RunTimeTicks\"`\n   633→\tUserData     struct {\n   634→\t\tPlayed         bool   `json:\"Played\"`\n   635→\t\tPlaybackPos    int64  `json:\"PlaybackPositionTicks\"`\n   636→\t\tPlayCount      int    `json:\"PlayCount\"`\n   637→\t\tLastPlayedDate string `json:\"LastPlayedDate\"`\n   638→\t} `json:\"UserData\"`\n   639→}\n   640→\n   641→//\n   642→// ---------- Now Playing (sessions) ----------\n   643→//\n   644→\n   645→type EmbySession struct {\n   646→\tSessionID string `json:\"SessionId\"`\n   647→\tUserID    string `json:\"UserId\"`\n   648→\tUserName  string `json:\"UserName\"`\n   649→\tItemID    string `json:\"ItemId\"`\n   650→\tItemName  string `json:\"ItemName\"`\n   651→\tItemType  string `json:\"ItemType\"`\n   652→\n   653→\t// Timestamp when playback position was last updated\n   654→\tPosTicks      int64 `json:\"PosTicks\"`\n   655→\tDurationTicks int64 `json:\"DurationTicks\"`\n   656→\n   657→\t// Client/device\n   658→\tApp    string `json:\"Client\"`\n   659→\tDevice string `json:\"DeviceName\"`\n   660→\n   661→\t// Playback details\n   662→\tPlayMethod string `json:\"PlayMethod,omitempty\"` // \"Direct\"/\"Transcode\"\n   663→\tVideoCodec string `json:\"VideoCodec,omitempty\"`\n   664→\tAudioCodec string `json:\"AudioCodec,omitempty\"`\n   665→\tSubsCount  int    `json:\"SubsCount,omitempty\"`\n   666→\tBitrate    int64  `json:\"Bitrate,omitempty\"` // bps\n   667→\n   668→\tContainer   string `json:\"Container,omitempty\"` // MKV/MP4\n   669→\tWidth       int    `json:\"Width,omitempty\"`\n   670→\tHeight      int    `json:\"Height,omitempty\"`\n   671→\tDolbyVision bool   `json:\"DolbyVision,omitempty\"`\n   672→\tHDR10       bool   `json:\"HDR10,omitempty\"`\n   673→\n   674→\tAudioLang    string `json:\"AudioLang,omitempty\"`\n   675→\tAudioCh      int    `json:\"AudioChannels,omitempty\"`\n   676→\tAudioDefault bool   `json:\"AudioDefault,omitempty\"` // NEW: Track if current audio is default\n   677→\n   678→\tSubLang  string `json:\"SubLang,omitempty\"`\n   679→\tSubCodec string `json:\"SubCodec,omitempty\"`\n   680→\n   681→\t// Transcode details (when PlayMethod=Transcode)\n   682→\tTransVideoFrom string `json:\"TransVideoFrom,omitempty\"`\n   683→\tTransVideoTo   string `json:\"TransVideoTo,omitempty\"`\n   684→\tTransAudioFrom string `json:\"TransAudioFrom,omitempty\"`\n   685→\tTransAudioTo   string `json:\"TransAudioTo,omitempty\"`\n   686→\n   687→\t// Per-track methods\n   688→\tVideoMethod string `json:\"VideoMethod,omitempty\"` // \"Direct Play\" or \"Transcode\"\n   689→\tAudioMethod string `json:\"AudioMethod,omitempty\"`\n   690→\n   691→\t// Transcode target details\n   692→\tTransContainer    string   `json:\"TransContainer,omitempty\"`\n   693→\tTransFramerate    float64  `json:\"TransFramerate,omitempty\"`\n   694→\tTransAudioBitrate int64    `json:\"TransAudioBitrate,omitempty\"`\n   695→\tTransVideoBitrate int64    `json:\"TransVideoBitrate,omitempty\"`\n   696→\tTransWidth        int      `json:\"TransWidth,omitempty\"`\n   697→\tTransHeight       int      `json:\"TransHeight,omitempty\"`\n   698→\tTransReasons      []string `json:\"TransReasons,omitempty\"`\n   699→\tTransCompletion   float64  `json:\"TransCompletion,omitempty\"`\n   700→    TransPosTicks     int64    `json:\"TransPosTicks,omitempty\"`\n   701→    RemoteAddress     string   `json:\"RemoteAddress,omitempty\"`\n   702→    IsPaused          bool     `json:\"IsPaused,omitempty\"`\n   703→}\n   704→\n   705→type rawSession struct {\n   706→\tId             string `json:\"Id\"` // session id\n   707→\tUserID         string `json:\"UserId\"`\n   708→\tUserName       string `json:\"UserName\"`\n   709→\tClient         string `json:\"Client\"`\n   710→\tDeviceName     string `json:\"DeviceName\"`\n   711→\tRemoteEndPoint string `json:\"RemoteEndPoint\"` // Emby provides remote IP address\n   712→\n   713→\tNowPlayingItem *struct {\n   714→\t\tId           string `json:\"Id\"`\n   715→\t\tName         string `json:\"Name\"`\n   716→\t\tType         string `json:\"Type\"`\n   717→\t\tRunTimeTicks int64  `json:\"RunTimeTicks\"`\n   718→\n   719→\t\tContainer string `json:\"Container\"`\n   720→\n   721→\t\tMediaStreams []struct {\n   722→\t\t\tIndex    int    `json:\"Index\"` // Stream index - this is key!\n   723→\t\t\tType     string `json:\"Type\"`  // \"Video\",\"Audio\",\"Subtitle\"\n   724→\t\t\tCodec    string `json:\"Codec\"` // e.g. h264,aac\n   725→\t\t\tLanguage string `json:\"Language\"`\n   726→\t\t\tChannels int    `json:\"Channels\"`\n   727→\t\t\tWidth    int    `json:\"Width\"`\n   728→\t\t\tHeight   int    `json:\"Height\"`\n   729→\n   730→\t\t\t// NEW for audio default detection\n   731→\t\t\tIsDefault bool `json:\"IsDefault\"`\n   732→\t\t\tDefault   bool `json:\"Default\"`\n   733→\n   734→\t\t\t// NEW: many Emby builds signal DV/HDR here\n   735→\t\t\tVideoRange     string `json:\"VideoRange\"`     // e.g. \"DOVI\", \"HDR10\", \"SDR\"\n   736→\t\t\tVideoRangeType string `json:\"VideoRangeType\"` // e.g. \"Dv\", \"Hdr10\", \"Sdr\"\n   737→\n   738→\t\t\t// Existing flags\n   739→\t\t\tIsHdr     bool `json:\"IsHdr\"`\n   740→\t\t\tHdr       bool `json:\"Hdr\"`\n   741→\t\t\tHdr10     bool `json:\"Hdr10\"`\n   742→\t\t\tDvProfile *int `json:\"DvProfile,omitempty\"`\n   743→\n   744→\t\t\tBitRate int64 `json:\"BitRate,omitempty\"`\n   745→\t\t\tBitrate int64 `json:\"Bitrate,omitempty\"`\n   746→\t\t} `json:\"MediaStreams\"`\n   747→\n   748→\t\t// Direct-play fallback (often in kbps)\n   749→\t\tMediaSources []struct {\n   750→\t\t\tBitrate int64 `json:\"Bitrate\"`\n   751→\t\t} `json:\"MediaSources\"`\n   752→\t} `json:\"NowPlayingItem\"`\n   753→\n   754→\tPlayState *struct {\n   755→\t\tPositionTicks       int64  `json:\"PositionTicks\"`\n   756→\t\tPlayMethod          string `json:\"PlayMethod\"`\n   757→\t\tIsPaused            bool   `json:\"IsPaused\"`\n   758→\t\tAudioStreamIndex    *int   `json:\"AudioStreamIndex\"`    // Currently selected audio stream\n   759→\t\tSubtitleStreamIndex *int   `json:\"SubtitleStreamIndex\"` // Currently selected subtitle stream\n   760→\t} `json:\"PlayState\"`\n   761→\n   762→\tTranscodingInfo *struct {\n   763→\t\tBitrate                int64    `json:\"Bitrate\"` // overall bps (target)\n   764→\t\tVideoCodec             string   `json:\"VideoCodec\"`\n   765→\t\tAudioCodec             string   `json:\"AudioCodec\"`\n   766→\t\tContainer              string   `json:\"Container\"`    // \"ts\", \"mp4\", \"fmp4\", ...\n   767→\t\tFramerate              float64  `json:\"Framerate\"`    // transcoder speed or output fps (server-dependent)\n   768→\t\tAudioBitrate           int64    `json:\"AudioBitrate\"` // target audio bps\n   769→\t\tVideoBitrate           int64    `json:\"VideoBitrate\"` // target video bps\n   770→\t\tWidth                  int      `json:\"Width\"`\n   771→\t\tHeight                 int      `json:\"Height\"`\n   772→\t\tTranscodeReasons       []string `json:\"TranscodeReasons\"`     // e.g. AudioCodecNotSupported\n   773→\t\tCompletionPercentage   float64  `json:\"CompletionPercentage\"` // if server reports it\n   774→\t\tTranscodePositionTicks int64    `json:\"TranscodePositionTicks\"`\n   775→\t} `json:\"TranscodingInfo\"`\n   776→}\n   777→\n   778→// GetActiveSessions returns only sessions that have a NowPlayingItem.\n   779→func (c *Client) GetActiveSessions() ([]EmbySession, error) {\n   780→\tu := fmt.Sprintf(\"%s/emby/Sessions\", c.BaseURL)\n   781→\tq := url.Values{}\n   782→\tq.Set(\"api_key\", c.APIKey)\n   783→\n   784→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n   785→\t// Some setups prefer header token; keep header for compatibility.\n   786→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n   787→\n   788→\tresp, err := c.doWithRetry(req, 2) // Retry up to 2 times\n   789→\tif err != nil {\n   790→\t\treturn nil, err\n   791→\t}\n   792→\n   793→\tvar raw []rawSession\n   794→\tif err := readJSON(resp, &raw); err != nil {\n   795→\t\treturn nil, err\n   796→\t}\n   797→\n   798→\tout := make([]EmbySession, 0, len(raw))\n   799→\tfor _, rs := range raw {\n   800→\t\t// Only show active playback\n   801→\t\tif rs.NowPlayingItem == nil || rs.NowPlayingItem.Id == \"\" {\n   802→\t\t\tcontinue\n   803→\t\t}\n   804→\n   805→\t\tes := EmbySession{\n   806→\t\t\tSessionID: rs.Id,\n   807→\t\t\tUserID:    rs.UserID,\n   808→\t\t\tUserName:  rs.UserName,\n   809→\t\t\tApp:       rs.Client,\n   810→\t\t\tDevice:    rs.DeviceName,\n   811→\t\t}\n   812→\n   813→\t\t// Item + duration\n   814→\t\tes.ItemID = rs.NowPlayingItem.Id\n   815→\t\tes.ItemName = rs.NowPlayingItem.Name\n   816→\t\tes.ItemType = rs.NowPlayingItem.Type\n   817→\t\tes.DurationTicks = rs.NowPlayingItem.RunTimeTicks\n   818→\n   819→\t\t// Capture additional media info defaults\n   820→\t\tes.Container = strings.ToUpper(rs.NowPlayingItem.Container)\n   821→\n   822→\t\t// Extract remote address\n   823→\t\tes.RemoteAddress = rs.RemoteEndPoint\n   824→\n   825→\t\t// Extract transcoding reasons if transcoding is active\n   826→\t\tif rs.TranscodingInfo != nil {\n   827→\t\t\tes.TransReasons = rs.TranscodingInfo.TranscodeReasons\n   828→\t\t}\n   829→\n   830→\t\t// Per-track and stream info\n   831→\t\tsubs := 0\n   832→\t\tstreamKbpsSum := int64(0)\n   833→\t\tvar sourceVideoCodec, sourceAudioCodec string\n   834→\n   835→\t\t// Get currently selected stream indices from PlayState\n   836→\t\tvar currentAudioIndex, currentSubtitleIndex *int\n   837→\t\tif rs.PlayState != nil {\n   838→\t\t\tcurrentAudioIndex = rs.PlayState.AudioStreamIndex\n   839→\t\t\tcurrentSubtitleIndex = rs.PlayState.SubtitleStreamIndex\n   840→\t\t}\n   841→\n   842→\t\t// Resolution / HDR / audio lang & channels / subs info\n   843→\t\tfor _, ms := range rs.NowPlayingItem.MediaStreams {\n   844→\t\t\tswitch strings.ToLower(ms.Type) {\n   845→\t\t\tcase \"video\":\n   846→\t\t\t\tif es.VideoCodec == \"\" && ms.Codec != \"\" {\n   847→\t\t\t\t\tes.VideoCodec = strings.ToUpper(ms.Codec)\n   848→\t\t\t\t}\n   849→\t\t\t\t// Always assign sourceVideoCodec if present\n   850→\t\t\t\tif ms.Codec != \"\" {\n   851→\t\t\t\t\tsourceVideoCodec = strings.ToUpper(ms.Codec)\n   852→\t\t\t\t}\n   853→\t\t\t\tif es.Width == 0 && ms.Width > 0 {\n   854→\t\t\t\t\tes.Width = ms.Width\n   855→\t\t\t\t\tes.Height = ms.Height\n   856→\t\t\t\t}\n   857→\t\t\t\t// HDR/DV detection (prefer DV if present)\n   858→\t\t\t\tvr := strings.ToLower(strings.TrimSpace(ms.VideoRange))\n   859→\t\t\t\tvrt := strings.ToLower(strings.TrimSpace(ms.VideoRangeType))\n   860→\t\t\t\tif (ms.DvProfile != nil && *ms.DvProfile > 0) ||\n   861→\t\t\t\t\tvr == \"dovi\" || vr == \"dolby vision\" || vr == \"dolbyvision\" ||\n   862→\t\t\t\t\tvrt == \"dv\" || vrt == \"dolbyvision\" {\n   863→\t\t\t\t\tes.DolbyVision = true\n   864→\t\t\t\t}\n   865→\t\t\t\tif ms.Hdr10 || ms.Hdr || ms.IsHdr ||\n   866→\t\t\t\t\tstrings.Contains(vr, \"hdr\") || vrt == \"hdr10\" || vrt == \"hdr10plus\" {\n   867→\t\t\t\t\tes.HDR10 = true\n   868→\t\t\t\t}\n   869→\t\t\t\tif ms.BitRate > 0 {\n   870→\t\t\t\t\tstreamKbpsSum += ms.BitRate\n   871→\t\t\t\t} else if ms.Bitrate > 0 {\n   872→\t\t\t\t\tstreamKbpsSum += ms.Bitrate\n   873→\t\t\t\t}\n   874→\t\t\tcase \"audio\":\n   875→\t\t\t\t// Check if this is the currently selected audio stream\n   876→\t\t\t\tisCurrentAudio := false\n   877→\t\t\t\tif currentAudioIndex != nil && *currentAudioIndex == ms.Index {\n   878→\t\t\t\t\tisCurrentAudio = true\n   879→\t\t\t\t} else if currentAudioIndex == nil && (ms.IsDefault || ms.Default) {\n   880→\t\t\t\t\t// Fallback to default if no current index is specified\n   881→\t\t\t\t\tisCurrentAudio = true\n   882→\t\t\t\t} else if currentAudioIndex == nil && es.AudioCodec == \"\" {\n   883→\t\t\t\t\t// Further fallback to first audio stream if no default found\n   884→\t\t\t\t\tisCurrentAudio = true\n   885→\t\t\t\t}\n   886→\n   887→\t\t\t\tif isCurrentAudio {\n   888→\t\t\t\t\tif ms.Codec != \"\" {\n   889→\t\t\t\t\t\tes.AudioCodec = strings.ToUpper(ms.Codec)\n   890→\t\t\t\t\t}\n   891→\t\t\t\t\t// Keep language as-is (don't force uppercase) so \"English\" stays \"English\"\n   892→\t\t\t\t\tif ms.Language != \"\" {\n   893→\t\t\t\t\t\tes.AudioLang = ms.Language\n   894→\t\t\t\t\t}\n   895→\t\t\t\t\tif ms.Channels > 0 {\n   896→\t\t\t\t\t\tes.AudioCh = ms.Channels\n   897→\t\t\t\t\t}\n   898→\t\t\t\t\t// Only mark as default if it's actually the default stream\n   899→\t\t\t\t\tif ms.IsDefault || ms.Default {\n   900→\t\t\t\t\t\tes.AudioDefault = true\n   901→\t\t\t\t\t}\n   902→\t\t\t\t}\n   903→\n   904→\t\t\t\t// Always assign sourceAudioCodec if not set and present\n   905→\t\t\t\tif sourceAudioCodec == \"\" && ms.Codec != \"\" {\n   906→\t\t\t\t\tsourceAudioCodec = strings.ToUpper(ms.Codec)\n   907→\t\t\t\t}\n   908→\n   909→\t\t\t\tif ms.BitRate > 0 {\n   910→\t\t\t\t\tstreamKbpsSum += ms.BitRate\n   911→\t\t\t\t} else if ms.Bitrate > 0 {\n   912→\t\t\t\t\tstreamKbpsSum += ms.Bitrate\n   913→\t\t\t\t}\n   914→\n   915→\t\t\tcase \"subtitle\":\n   916→\t\t\t\tsubs++\n   917→\t\t\t\t// Check if this is the currently selected subtitle stream\n   918→\t\t\t\tisCurrentSubtitle := false\n   919→\t\t\t\tif currentSubtitleIndex != nil && *currentSubtitleIndex == ms.Index {\n   920→\t\t\t\t\tisCurrentSubtitle = true\n   921→\t\t\t\t} else if currentSubtitleIndex == nil && es.SubLang == \"\" {\n   922→\t\t\t\t\t// Only take first sub details if no specific one is selected and we haven't set one yet\n   923→\t\t\t\t\tisCurrentSubtitle = true\n   924→\t\t\t\t}\n   925→\n   926→\t\t\t\tif isCurrentSubtitle {\n   927→\t\t\t\t\tif ms.Language != \"\" {\n   928→\t\t\t\t\t\tes.SubLang = strings.ToUpper(ms.Language)\n   929→\t\t\t\t\t}\n   930→\t\t\t\t\tif ms.Codec != \"\" {\n   931→\t\t\t\t\t\tes.SubCodec = strings.ToUpper(ms.Codec)\n   932→\t\t\t\t\t}\n   933→\t\t\t\t}\n   934→\t\t\t}\n   935→\t\t}\n   936→\t\tes.SubsCount = subs\n   937→\n   938→        // PlayState\n   939→        if rs.PlayState != nil {\n   940→            es.PosTicks = rs.PlayState.PositionTicks\n   941→            es.IsPaused = rs.PlayState.IsPaused\n   942→            if rs.PlayState.PlayMethod != \"\" {\n   943→                if strings.HasPrefix(strings.ToLower(rs.PlayState.PlayMethod), \"trans\") {\n   944→                    es.PlayMethod = \"Transcode\"\n   945→                } else {\n   946→                    es.PlayMethod = \"Direct\"\n   947→                }\n   948→            }\n   949→        }\n   950→\t\tif es.PlayMethod == \"\" {\n   951→\t\t\tes.PlayMethod = \"Direct\"\n   952→\t\t}\n   953→\n   954→\t\t// Bitrate selection and transcode info\n   955→\t\tif rs.TranscodingInfo != nil && rs.TranscodingInfo.Bitrate > 0 {\n   956→\t\t\tes.Bitrate = rs.TranscodingInfo.Bitrate\n   957→\n   958→\t\t\t// Target (TO) codecs/container/etc\n   959→\t\t\tes.TransContainer = strings.ToUpper(rs.TranscodingInfo.Container)\n   960→\t\t\tes.TransFramerate = rs.TranscodingInfo.Framerate\n   961→\t\t\tes.TransAudioBitrate = rs.TranscodingInfo.AudioBitrate\n   962→\t\t\tes.TransVideoBitrate = rs.TranscodingInfo.VideoBitrate\n   963→\t\t\tes.TransWidth = rs.TranscodingInfo.Width\n   964→\t\t\tes.TransHeight = rs.TranscodingInfo.Height\n   965→\t\t\tes.TransReasons = append(es.TransReasons, rs.TranscodingInfo.TranscodeReasons...)\n   966→\t\t\tes.TransCompletion = rs.TranscodingInfo.CompletionPercentage\n   967→\t\t\tes.TransPosTicks = rs.TranscodingInfo.TranscodePositionTicks\n   968→\n   969→\t\t\tif v := rs.TranscodingInfo.VideoCodec; v != \"\" {\n   970→\t\t\t\tes.TransVideoTo = strings.ToUpper(v)\n   971→\t\t\t}\n   972→\t\t\tif a := rs.TranscodingInfo.AudioCodec; a != \"\" {\n   973→\t\t\t\tes.TransAudioTo = strings.ToUpper(a)\n   974→\t\t\t}\n   975→\n   976→\t\t\t// Fill FROM using detected source codecs\n   977→\t\t\tif sourceVideoCodec != \"\" {\n   978→\t\t\t\tes.TransVideoFrom = sourceVideoCodec\n   979→\t\t\t}\n   980→\t\t\tif sourceAudioCodec != \"\" {\n   981→\t\t\t\tes.TransAudioFrom = sourceAudioCodec\n   982→\t\t\t}\n   983→\n   984→\t\t\tes.PlayMethod = \"Transcode\"\n   985→\t\t} else {\n   986→\t\t\t// 2) MediaSource bitrate (often kbps)\n   987→\t\t\tif rs.NowPlayingItem != nil && len(rs.NowPlayingItem.MediaSources) > 0 {\n   988→\t\t\t\tif b := rs.NowPlayingItem.MediaSources[0].Bitrate; b > 0 {\n   989→\t\t\t\t\tes.Bitrate = normalizeToBps(b)\n   990→\t\t\t\t}\n   991→\t\t\t}\n   992→\t\t\t// 3) Sum stream bitrates (kbps) if source bitrate missing\n   993→\t\t\tif es.Bitrate == 0 && streamKbpsSum > 0 {\n   994→\t\t\t\tes.Bitrate = normalizeToBps(streamKbpsSum)\n   995→\t\t\t}\n   996→\t\t}\n   997→\n   998→\t\t// Decide per-track methods\n   999→\t\tes.VideoMethod = \"Direct Play\"\n  1000→\t\tes.AudioMethod = \"Direct Play\"\n  1001→\t\tif es.PlayMethod == \"Transcode\" {\n  1002→\t\t\tif es.TransVideoFrom != \"\" && es.TransVideoTo != \"\" && es.TransVideoFrom != es.TransVideoTo {\n  1003→\t\t\t\tes.VideoMethod = \"Transcode\"\n  1004→\t\t\t}\n  1005→\t\t\tif es.TransAudioFrom != \"\" && es.TransAudioTo != \"\" && es.TransAudioFrom != es.TransAudioTo {\n  1006→\t\t\t\tes.AudioMethod = \"Transcode\"\n  1007→\t\t\t}\n  1008→\t\t}\n  1009→\n  1010→\t\tout = append(out, es)\n  1011→\t}\n  1012→\treturn out, nil\n  1013→}\n  1014→\n  1015→//\n  1016→// ---------- Session controls (pause/play/stop/message) ----------\n  1017→//\n  1018→\n  1019→func (c *Client) Pause(sessionID string) error {\n  1020→\tu := fmt.Sprintf(\"%s/emby/Sessions/%s/Playing/Pause?api_key=%s\", c.BaseURL, sessionID, url.QueryEscape(c.APIKey))\n  1021→\treq, _ := http.NewRequest(\"POST\", u, nil)\n  1022→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n  1023→\t_, err := c.http.Do(req)\n  1024→\treturn err\n  1025→}\n  1026→\n  1027→func (c *Client) Unpause(sessionID string) error {\n  1028→\tu := fmt.Sprintf(\"%s/emby/Sessions/%s/Playing/Unpause?api_key=%s\", c.BaseURL, sessionID, url.QueryEscape(c.APIKey))\n  1029→\treq, _ := http.NewRequest(\"POST\", u, nil)\n  1030→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n  1031→\t_, err := c.http.Do(req)\n  1032→\treturn err\n  1033→}\n  1034→\n  1035→func (c *Client) Stop(sessionID string) error {\n  1036→\tu := fmt.Sprintf(\"%s/emby/Sessions/%s/Playing/Stop?api_key=%s\", c.BaseURL, sessionID, url.QueryEscape(c.APIKey))\n  1037→\treq, _ := http.NewRequest(\"POST\", u, nil)\n  1038→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n  1039→\t_, err := c.http.Do(req)\n  1040→\treturn err\n  1041→}\n  1042→\n  1043→func (c *Client) SendMessage(sessionID, header, text string, timeoutMs int) error {\n  1044→\tif timeoutMs <= 0 {\n  1045→\t\ttimeoutMs = 5000\n  1046→\t}\n  1047→\tpayload := map[string]any{\n  1048→\t\t\"Header\":    header,\n  1049→\t\t\"Text\":      text,\n  1050→\t\t\"TimeoutMs\": timeoutMs,\n  1051→\t}\n  1052→\tb, _ := json.Marshal(payload)\n  1053→\tu := fmt.Sprintf(\"%s/emby/Sessions/%s/Message?api_key=%s\", c.BaseURL, sessionID, url.QueryEscape(c.APIKey))\n  1054→\treq, _ := http.NewRequest(\"POST\", u, bytes.NewReader(b))\n  1055→\treq.Header.Set(\"Content-Type\", \"application/json\")\n  1056→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n  1057→\t_, err := c.http.Do(req)\n  1058→\treturn err\n  1059→}\n  1060→\n  1061→type EmbySystemInfo struct {\n  1062→\tID   string `json:\"Id\"`\n  1063→\tName string `json:\"ServerName\"`\n  1064→}\n  1065→\n  1066→// GetSystemInfo fetches server information including the server ID\n  1067→func (c *Client) GetSystemInfo() (*EmbySystemInfo, error) {\n  1068→\tu := fmt.Sprintf(\"%s/emby/System/Info\", c.BaseURL)\n  1069→\tq := url.Values{}\n  1070→\tq.Set(\"api_key\", c.APIKey)\n  1071→\n  1072→\treq, _ := http.NewRequest(\"GET\", u+\"?\"+q.Encode(), nil)\n  1073→\treq.Header.Set(\"X-Emby-Token\", c.APIKey)\n  1074→\n  1075→\tresp, err := c.http.Do(req)\n  1076→\tif err != nil {\n  1077→\t\treturn nil, err\n  1078→\t}\n  1079→\n  1080→\tvar info EmbySystemInfo\n  1081→\tif err := readJSON(resp, &info); err != nil {\n  1082→\t\treturn nil, err\n  1083→\t}\n  1084→\n  1085→\treturn &info, nil\n  1086→}\n  1087→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I have all the context I need to create a comprehensive context manifest. Let me update the task file with the detailed context information."
      }
    ]
  }
]